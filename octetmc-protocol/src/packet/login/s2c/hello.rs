//! `0x01` `hello`


use crate::value::varint::VarInt;
use crate::packet::StateLogin;
use crate::packet::encode::{ EncodeBuf, PacketEncode, PacketPartEncode };
use std::borrow::Cow;


/// https://minecraft.wiki/w/Java_Edition_protocol/Packets#Encryption_Request
#[derive(Debug, Clone)]
pub struct HelloS2CLoginPacket<'l> {

    /// The server ID used in authentication.
    ///
    /// The vanilla server will send an empty string.
    pub server_id       : Cow<'l, str>,

    /// The server's public key.
    pub public_key      : Cow<'l, [u8]>,

    /// A random sequence of bytes generated by the server.
    pub verify_token    : Cow<'l, [u8]>,

    /// Whether the client shuold attempt to authencate through mojauth.
    pub mojauth_enabled : bool

}


impl HelloS2CLoginPacket<'_> {

    /// Convert the inner parts of this packet to their owned counterparts, or
    ///  take ownership if they are already owned. Returns the newly created
    ///  `HelloS2CLoginPacket<'static>`.
    #[inline]
    pub fn into_static_owned(self) -> HelloS2CLoginPacket<'static> {
        HelloS2CLoginPacket {
            server_id       : Cow::Owned(self.server_id.into_owned()),
            public_key      : Cow::Owned(self.public_key.into_owned()),
            verify_token    : Cow::Owned(self.verify_token.into_owned()),
            mojauth_enabled : self.mojauth_enabled
        }
    }

    /// Convert the inner parts of this packet to their owned counterparts.
    ///  Returns the newly created `HelloS2CLoginPacket<'static>`.
    #[inline]
    pub fn to_static_owned(&self) -> HelloS2CLoginPacket<'static> {
        HelloS2CLoginPacket {
            server_id       : Cow::Owned((*self.server_id).to_owned()),
            public_key      : Cow::Owned((*self.public_key).to_owned()),
            verify_token    : Cow::Owned((*self.verify_token).to_owned()),
            mojauth_enabled : self.mojauth_enabled
        }
    }

}


impl PacketEncode for HelloS2CLoginPacket<'_> {
    type State = StateLogin;

    const PREFIX : u8 = 0x01;

    fn predict_size(&self) -> usize {
        self.server_id.predict_size()
        + VarInt::<u32>::MAX_BYTES
        + self.public_key.len()
        + VarInt::<u32>::MAX_BYTES
        + self.verify_token.len()
        + 1
    }

    fn encode(&self, buf : &mut EncodeBuf) {
        buf.encode_write(&*self.server_id);
        buf.encode_write(VarInt::<u32>::from(self.public_key.len() as u32));
        buf.write_n(&self.public_key);
        buf.encode_write(VarInt::<u32>::from(self.verify_token.len() as u32));
        buf.write_n(&self.verify_token);
        buf.write(self.mojauth_enabled);
    }
}
